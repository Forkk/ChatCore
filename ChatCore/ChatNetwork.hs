-- | Network logic module.
module ChatCore.ChatNetwork where

import Control.Applicative
import Control.Lens
import Control.Monad
import Data.Acid
import qualified Data.IxSet as I
import Data.Maybe
import Data.Monoid
import qualified Data.Text as T
import Data.Typeable
import FRP.Sodium
import FRP.Sodium.IO
import Network

import ChatCore.ChatBuffer
import ChatCore.Events
import ChatCore.IRC
import ChatCore.IRC.FRP
import ChatCore.State
import ChatCore.Types


-- | The @ChatNetwork@ object holds the state information for a particular IRC network.
-- It is composed of multiple objects which are joined together by lenses.
-- NOTE: The `Eq` and `Ord` instances for @ChatNetwork@ only compare the network name.
data ChatNetwork = ChatNetwork
    { _chatNetworkName :: ChatNetworkName
    , _bNetworkStatus :: Behavior ConnectionStatus
    , _bNetworkUserNick :: Behavior Nick
    , _bNetworkBuffers :: Behavior (I.IxSet ChatBuffer)
    , _eNetworkCoreEvt :: Event CoreEvent
    , cleanupChatNetwork :: IO ()
    } deriving (Typeable)
$(makeLenses ''ChatNetwork)


-- | Set up behaviors and events for the given network.
chatNetwork :: ChatUserName -> ChatCoreNetwork
            -> AcidState ChatCoreState
            -> Event ClientCommand
            -> IO ChatNetwork
chatNetwork uName network acid eClientCmd =
    -- TODO: Manage this thread.
    -- ircConn <- connectIRC "irc.esper.net" (PortNumber 6667) eSendIrcLine
    sync $ do
        let netName = network ^. netStName
        rec
          --------------------------------------------------------------------------------
          -- IRC Connection
          --------------------------------------------------------------------------------

          let newConnForServer = connectIRC
                                 <$> (T.unpack . view serverHost)
                                 <*> (PortNumber . fromIntegral . view serverPort)
                                 <*> pure eSendLine
          -- TODO: Pull from the database and cycle through servers.
          let bIrcServer = pure $ ChatCoreNetServer "irc.esper.net" 6667

          -- New connection events are generated by executing `newConnForServer`
          -- every time the `bIrcServer` behavior changes.
          let eNewConnection = executeAsyncIO (newConnForServer <$> value bIrcServer)

          -- The IRC connection behavior. Initially holds a null connection, and
          -- takes new connections from the `eNewConnection` event.
          -- TODO: Close the old connection when a new one is opened.
          bIrcConn <- hold nullConn eNewConnection

          -- Connection status just pulls from the IRC connection object.
          -- TODO: Reconnect automatically.
          bConnStatus <- switch (ircConnStatus <$> bIrcConn)

          -- Some convenient events for handling connection and disconnection.
          let eConnected = void (filterE (==Connected) $ value bConnStatus)
              -- eDisconnected = void (filterE (==Disconnected) $ value bConnStatus)

          --------------------------------------------------------------------------------
          -- Receiving
          --------------------------------------------------------------------------------

          -- The receive line event just takes the curren't connection's receive line event.
          let eRecvLine = switchE (ircRecvLine <$> bIrcConn)

          -- An event which fires when we have finished initializing the IRC connection.
          let eConnComplete = void $ eRecvCmd $ ICmdOther "001"


          -------- IRC Line Utilities --------

          -- An event which receives IRC lines with the given command.
          let eRecvCmd :: IRCCommand -> Event IRCLine
              eRecvCmd = filterCmd eRecvLine
          
          -- Filters only IRC lines where the source is the current user.
          let filterSelfSource :: Event IRCLine -> Event IRCLine
              filterSelfSource eLine =
                  filterJust (snapshot doFilter eLine bUserNick)
                where
                  doFilter line nick =
                      if srcNick line == Just nick
                         then Just line
                         else Nothing
                  srcNick = preview (ilSource . _Just . _UserSource . iuNick)

          -- Filters out the first argument of the given lines.
          let filterFirstArg :: Event IRCLine -> Event T.Text
              filterFirstArg eLine = filterJust (preview (ilArgs . _head) <$> eLine)

          --------------------------------------------------------------------------------
          -- State
          --------------------------------------------------------------------------------

          bNetStBuffers <- hold (network ^. netStBuffers) never
          -- Link the bNetStBuffers behavior to the database.
          cleanNetStBufs <- linkAcidState acid (SetNetworkBuffers uName netName) bNetStBuffers

          let eNickChange = view (ilArgs . _head) <$> eRecvCmd ICmdNick
          -- The initial nick on connect is specified in the first argument of RPL_WELCOME.
          let eInitialNick = view (ilArgs ._head) <$> eRecvCmd (ICmdOther "001")

          bUserNick :: Behavior Nick <- hold "" (eNickChange <> eInitialNick)


          --------------------------------------------------------------------------------
          -- Buffers
          --------------------------------------------------------------------------------

          bBuffers <- accum I.empty (eAddBuffer <> eRemoveBuffer)
          let bBufferList = I.toList <$> bBuffers

          -- Buffer Events
          let eBufferEvent :: Event CoreEvent
              eBufferEvent = switchE (foldr merge never
                                      <$> map tagBufEvents
                                      <$> bBufferList)
          
          -- Tags events in the given buffer event stream as core events with
          -- the given buffer and the current network name.
          let tagBufEvents :: ChatBuffer -> Event CoreEvent
              tagBufEvents buf = ChatBufferEvent netName bufName <$> eBufEvt
                where
                  bufName = view bufferName buf
                  eBufEvt = view bufferEvent buf


          -- Find join events involving us and use them to add buffers.
          let eSelfJoin = filterFirstArg $ filterSelfSource $ eRecvCmd ICmdJoin
              eSelfPart = filterFirstArg $ filterSelfSource $ eRecvCmd ICmdPart

          let eAddBuffer = uncurry I.updateIx <$> execute (mkBuffer <$> eSelfJoin)
              eRemoveBuffer = I.deleteIx <$> eSelfPart

          let mkBuffer :: ChatBufferName -> Reactive (ChatBufferName, ChatBuffer)
              mkBuffer bufName = (bufName, ) <$> chatBuffer uName netName bufName eBufLine
                where eBufLine = filterE (isForBuffer bufName) eRecvLine


          --------------------------------------------------------------------------------
          -- Core Events
          --------------------------------------------------------------------------------

          let eCoreEvent = eBufferEvent


          --------------------------------------------------------------------------------
          -- Client Commands
          --------------------------------------------------------------------------------

          -- An IRC line event stream containing IRC lines derived from commands such as
          -- `SendMessage` which are directly translated into IRC lines.
          let eClientCmdLines = filterJust (lineForCmd <$> eClientCmd)
              lineForCmd (SendMessage _ dest content) = Just $ privMsgLine dest content
              lineForCmd (JoinChannel _ chan) = Just $ joinLine chan
              lineForCmd (PartChannel _ chan msgM) = Just $ partLine chan (fromMaybe "" msgM)
              -- lineForCmd _ = Nothing

          --------------------------------------------------------------------------------
          -- Sending Lines
          --------------------------------------------------------------------------------

          -- Event for sending a line.
          let eSendLine = eSendInit <> eJoinInitChans
                       <> eClientCmdLines
                       <> eSendPong

          -- On connect, send a nick and user command.
          let eSendInit = split (const [ userLine "ChatCore" "Chat Core"
                                       , nickLine "ChatCore"
                                       ] <$> eConnected)

          -- An event which sends IRC commands to join initial channels.
          let eJoinInitChans = split (snapshot (\_ cmds -> cmds) eConnComplete bInitJoinCmds)
              bInitJoinCmds = map (joinLine . view ccBufferName) <$> bActiveChans
              bActiveChans = filter isActiveChannel <$> I.toList <$> bNetStBuffers
              isActiveChannel (ChatCoreChannelBuffer _ True) = True
              isActiveChannel _ = False

          -- When a PING message is received, send a PONG.
          let eSendPong = pongLine <$> view ilBody <$> eRecvCmd ICmdPing


        --------------------------------------------------------------------------------
        -- Cleanup
        --------------------------------------------------------------------------------

        cleanSendLnPrnt <- listen eSendLine (putStrLn . ("Sent line: "++) . show)
        cleanRecvLnPrnt <- listen eRecvLine (putStrLn . ("Received line: "++) . show)
        cleanBufEvtPrnt <- listen eBufferEvent (putStrLn . ("Buffer event: "++) . show)

        cleanConStatPrnt <- listen (value bConnStatus) print

        let bCleanupBuffers = map cleanupChatBuffer <$> bBufferList
        let clean = do
              join (sequence_ <$> sync (sample bCleanupBuffers))
              cleanNetStBufs
              cleanConStatPrnt
              cleanRecvLnPrnt
              cleanSendLnPrnt
              cleanBufEvtPrnt

        return $ ChatNetwork
               netName bConnStatus bUserNick bBuffers eCoreEvent clean


getNetworkInfo :: ChatNetwork -> Behavior ChatNetworkInfo
getNetworkInfo net = ChatNetworkInfo
                     <$> pure (net ^. chatNetworkName)
                     <*> (net ^. bNetworkStatus)
                     <*> (net ^. bNetworkUserNick)


--------------------------------------------------------------------------------
-- Indexable
--------------------------------------------------------------------------------

instance I.Indexable ChatNetwork where
    empty = I.ixSet [ I.ixFun ((:[]) . view chatNetworkName) ]

-- Eq and Ord so we can use IxSet.
instance Eq ChatNetwork where
    a == b = netName a == netName b
      where
        netName = view chatNetworkName

instance Ord ChatNetwork where
    compare a b = netName a `compare` netName b
      where
        netName = view chatNetworkName
