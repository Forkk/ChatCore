-- | Network logic module.
module ChatCore.ChatNetwork where

import Control.Applicative
import Control.Lens
import Control.Monad
import Data.Acid
import qualified Data.IxSet as I
import Data.Maybe
import Data.Monoid
import qualified Data.Text as T
import Data.Typeable
import FRP.Sodium
import FRP.Sodium.IO
import Network

import ChatCore.ChatBuffer
import ChatCore.Events
import ChatCore.IRC
import ChatCore.IRC.FRP
import ChatCore.State
import ChatCore.Types
import ChatCore.Util.FRP


-- | The @ChatNetwork@ object holds the state information for a particular IRC network.
-- It is composed of multiple objects which are joined together by lenses.
-- NOTE: The `Eq` and `Ord` instances for @ChatNetwork@ only compare the network name.
data ChatNetwork = ChatNetwork
    { _chatNetworkName :: ChatNetworkName
    , _bNetworkStatus :: Behavior ConnectionStatus
    , _bNetworkUserNick :: Behavior Nick
    , _bNetworkBuffers :: Behavior (I.IxSet ChatBuffer)
    , _eNetworkCoreEvt :: Event CoreEvent
    , cleanupChatNetwork :: IO ()
    } deriving (Typeable)
$(makeLenses ''ChatNetwork)


-- | Set up behaviors and events for the given network.
chatNetwork :: ChatUserName -> ChatCoreNetwork
            -> AcidState ChatCoreState
            -> Event ClientCommand
            -> IO ChatNetwork
chatNetwork uName network acid eClientCmd =
    -- TODO: Manage this thread.
    -- ircConn <- connectIRC "irc.esper.net" (PortNumber 6667) eSendIrcLine
    sync $ do
        let netName = network ^. netStName
        rec
          (eInit', pushInit) <- newEvent
          let eInit = once eInit'

          --------------------------------------------------------------------------------
          -- IRC Connection
          --------------------------------------------------------------------------------

          let newConnForServer = connectIRC
                                 <$> (T.unpack . view serverHost)
                                 <*> (PortNumber . fromIntegral . view serverPort)
                                 <*> pure eSendLine
          -- TODO: Pull from the database and cycle through servers.
          let bIrcServer = pure $ ChatCoreNetServer "irc.esper.net" 6667

          -- New connection events are generated by executing `newConnForServer`
          -- every time the `bIrcServer` behavior changes.
          let eNewConnection = executeAsyncIO (newConnForServer <$> value bIrcServer)

          -- The IRC connection behavior. Initially holds a null connection, and
          -- takes new connections from the `eNewConnection` event.
          -- TODO: Close the old connection when a new one is opened.
          bIrcConn <- hold nullConn eNewConnection

          -- Connection status just pulls from the IRC connection object.
          -- TODO: Reconnect automatically.
          bConnStatus <- switch (ircConnStatus <$> bIrcConn)

          -- Some convenient events for handling connection and disconnection.
          let eConnected = void (filterE (==Connected) $ value bConnStatus)
              -- eDisconnected = void (filterE (==Disconnected) $ value bConnStatus)

          --------------------------------------------------------------------------------
          -- Receiving
          --------------------------------------------------------------------------------

          -- The receive line event just takes the curren't connection's receive line event.
          let eRecvLine = switchE (ircRecvLine <$> bIrcConn)

          -- An event which fires when we have finished initializing the IRC connection.
          let eConnComplete = void $ eRecvCmd $ ICmdOther "001"


          -------- IRC Line Utilities --------

          -- An event which receives IRC lines with the given command.
          let eRecvCmd :: IRCCommand -> Event IRCLine
              eRecvCmd = filterCmd eRecvLine
          

          --------------------------------------------------------------------------------
          -- Buffers
          --------------------------------------------------------------------------------

          bBuffers <- accum I.empty (eDoAddNewBuf <> eDoAddInitBuf)
          let bBufferList :: Behavior [ChatBuffer]
              bBufferList = I.toList <$> bBuffers

          -- Buffer Events
          let eBufferEvent :: Event CoreEvent
              eBufferEvent = switchE (foldr merge never
                                      <$> map tagBufEvents
                                      <$> bBufferList)
          
          -- Tags events in the given buffer event stream as core events with
          -- the given buffer and the current network name.
          let tagBufEvents :: ChatBuffer -> Event CoreEvent
              tagBufEvents buf = ChatBufferEvent netName bufName <$> eBufEvt
                where
                  bufName = view bufferName buf
                  eBufEvt = view bufferEvent buf


          -- Find join events involving us and use them to add buffers.
          let eSelfJoin = filterFirstArg $ filterSelfSource bUserNick $ eRecvCmd ICmdJoin

          let eDoAddNewBuf = doAddBuf $ filterJust $ execute (mkNewBuf <$> eSelfJoin)
              eDoAddInitBuf = doAddBuf eInitBuf

          let doAddBuf :: Event ChatCoreBuffer
                       -> Event (I.IxSet ChatBuffer -> I.IxSet ChatBuffer)
              doAddBuf eBuf = uncurry I.updateIx <$> execute (mkBuffer <$> eBuf)
          
          let eInitBuf :: Event ChatCoreBuffer
              eInitBuf = split (const (I.toList (network ^. netStBuffers)) <$> eInit)

          -- Initializes a `ChatBuffer` object for the given buffer and inserts
          -- it into a tuple with the buffer name so that it can be put into an
          -- IxSet.
          let mkBuffer :: ChatCoreBuffer -> Reactive (ChatBufferName, ChatBuffer)
              mkBuffer buf = (bufName, ) <$> chatBuffer uName netName bufName
                                                        (_ccBufferActive buf)
                                                        bUserNick eBufLine
                where
                  eBufLine = filterE (isForBuffer bufName) eRecvLine
                  bufName = buf ^. ccBufferName

          -- If the given buffer is not already in the buffer list, creates a
          -- new ChatCoreBuffer structure for it.
          let mkNewBuf :: ChatBufferName -> Reactive (Maybe ChatCoreBuffer)
              mkNewBuf bufName = do
                  exists <- not <$> I.null
                            <$> I.getEQ bufName
                            <$> sample bBuffers
                  return $ if exists then Nothing else Just newBuf
                where
                  newBuf = ChatCoreChannelBuffer bufName True


          --------------------------------------------------------------------------------
          -- State
          --------------------------------------------------------------------------------

          bNetStBuffers <- fmap I.fromList <$> switchList (map bufStateBehavior <$> bBufferList)
          -- Link the bNetStBuffers behavior to the database.
          cleanNetStBufs <- execAcidUpdates acid
                            (SetNetworkBuffers uName netName
                             <$> updates bNetStBuffers)

          let eNickChange = view (ilArgs . _head) <$> eRecvCmd ICmdNick
          -- The initial nick on connect is specified in the first argument of RPL_WELCOME.
          let eInitialNick = view (ilArgs ._head) <$> eRecvCmd (ICmdOther "001")

          bUserNick :: Behavior Nick <- hold "" (eNickChange <> eInitialNick)


          --------------------------------------------------------------------------------
          -- Core Events
          --------------------------------------------------------------------------------

          let eCoreEvent = eBufferEvent


          --------------------------------------------------------------------------------
          -- Client Commands
          --------------------------------------------------------------------------------

          -- An IRC line event stream containing IRC lines derived from commands such as
          -- `SendMessage` which are directly translated into IRC lines.
          let eClientCmdLines = filterJust (lineForCmd <$> eClientCmd)
              lineForCmd (SendMessage _ dest content) = Just $ privMsgLine dest content
              lineForCmd (JoinChannel _ chan) = Just $ joinLine chan
              lineForCmd (PartChannel _ chan msgM) = Just $ partLine chan (fromMaybe "" msgM)
              -- lineForCmd _ = Nothing

          --------------------------------------------------------------------------------
          -- Sending Lines
          --------------------------------------------------------------------------------

          -- Event for sending a line.
          let eSendLine = eSendInit <> eCmdJoinInitChans
                       <> eClientCmdLines
                       <> eSendPong

          -- On connect, send a nick and user command.
          let eSendInit = split (const [ userLine "ChatCore" "Chat Core"
                                       , nickLine "ChatCore"
                                       ] <$> eConnected)

          -- An event which sends IRC commands to join initial channels.
          let eCmdJoinInitChans = joinLine <$> view ccBufferName <$> split eJoinInitChans
              eJoinInitChans = snapshot (const getActiveChans) eConnComplete bNetStBuffers
              getActiveChans = filter isActiveChannel . I.toList
              isActiveChannel (ChatCoreChannelBuffer _ True) = True
              isActiveChannel _ = False

          -- When a PING message is received, send a PONG.
          let eSendPong = pongLine <$> view ilBody <$> eRecvCmd ICmdPing


        --------------------------------------------------------------------------------
        -- Cleanup
        --------------------------------------------------------------------------------

        cleanSendLnPrnt <- listen eSendLine (putStrLn . ("Sent line: "++) . show)
        cleanRecvLnPrnt <- listen eRecvLine (putStrLn . ("Received line: "++) . show)
        cleanBufEvtPrnt <- listen eBufferEvent (putStrLn . ("Buffer event: "++) . show)

        cleanConStatPrnt <- listen (value bConnStatus) print

        let bCleanupBuffers = map cleanupChatBuffer <$> bBufferList
        let clean = do
              join (sequence_ <$> sync (sample bCleanupBuffers))
              cleanNetStBufs
              cleanConStatPrnt
              cleanRecvLnPrnt
              cleanSendLnPrnt
              cleanBufEvtPrnt

        pushInit ()

        return $ ChatNetwork
               netName bConnStatus bUserNick bBuffers eCoreEvent clean


getNetworkInfo :: ChatNetwork -> Behavior ChatNetworkInfo
getNetworkInfo net = ChatNetworkInfo
                     <$> pure (net ^. chatNetworkName)
                     <*> (net ^. bNetworkStatus)
                     <*> (net ^. bNetworkUserNick)


--------------------------------------------------------------------------------
-- Indexable
--------------------------------------------------------------------------------

instance I.Indexable ChatNetwork where
    empty = I.ixSet [ I.ixFun ((:[]) . view chatNetworkName) ]

-- Eq and Ord so we can use IxSet.
instance Eq ChatNetwork where
    a == b = netName a == netName b
      where
        netName = view chatNetworkName

instance Ord ChatNetwork where
    compare a b = netName a `compare` netName b
      where
        netName = view chatNetworkName
