-- | Module for ChatCore's event data types.
-- There are two different types of events: client commands and core events.
-- Client commands are generated by the protocol handling system. They are
-- events that come from clients connected to the core.
-- Core events are generated by the chat controller. Most come from IRC events
-- that have been processed, but some can come from the core internally. Core
-- events are sent to clients. Which clients they're sent to depends on the
-- situation. Client commands are sent to the chat controller.
module ChatCore.Events where

import Control.Applicative
import Data.Aeson
import Data.Aeson.Types
import Data.Maybe
import qualified Data.Text as T

import ChatCore.Types

-- | Data structure representing a Chat Core client command.
--   A client command represents a message or request from a client.
data ClientCommand
    -- | Send the given message to the given destination.
    = SendMessage
        { sendMsgNetwork    :: ChatNetworkId    -- ID of the IRC network to send the message on.
        , sendMsgDest       :: ChatDest         -- Destination to send the message to.
        , sendMsgContent    :: T.Text           -- Content of the message.
        , sendMsgType       :: MessageType      -- The type of message (PRIVMSG or NOTICE).
        }
    | JoinChannel ChatNetworkId ChatChan
    | PartChannel ChatNetworkId ChatChan (Maybe T.Text)
    deriving (Show)


-- | Data structure representing a Chat Core core event.
-- A core event represents something that happened on the server that needs to
-- be translated into a message that the client can understand.
data CoreEvent
    -- | Wrapper for `BufferCoreEvent`s. These are events that relate to a
    -- specific buffer.
    = BufCoreEvent ChatNetworkId ChatBufferId BufferEvent

-- | Data structure for core events that relate to a specific buffer.
-- These events are usually wrapped in the `CoreEvent` object's `BufCoreEvent`
-- constructor.
data BufferEvent
    -- | Represents a new message from the given source.
    = ReceivedMessage
        { recvMsgSender     :: User             -- The the user who sent the message.
        , recvMsgContent    :: T.Text           -- The content of the message.
        , recvMsgType       :: MessageType      -- The type of message (PRIVMSG or NOTICE).
        }
    | UserJoin User
    | UserPart User (Maybe T.Text)
    | UserQuit User (Maybe T.Text)
    deriving (Show, Eq)

-- {{{ Buffer Event to JSON

instance ToJSON BufferEvent where
    toJSON = object . bufEvtPairs

bufEvtPairs :: BufferEvent -> [Pair]
bufEvtPairs evt@(ReceivedMessage {}) =
    [ "event"       .= ("recvmsg" :: T.Text)
    , "sender"      .= recvMsgSender evt
    , "message"     .= recvMsgContent evt
    , "msgtype"     .= recvMsgType evt
    ]
bufEvtPairs (UserJoin user) =
    [ "event" .= ("join" :: T.Text)
    , "user"  .= user
    ]
bufEvtPairs (UserPart user msgM) =
    [ "event"   .= ("part" :: T.Text)
    , "user"    .= user
    ] ++ if isJust msgM
            then ["message" .= fromJust msgM]
            else []
bufEvtPairs (UserQuit user msgM) =
    [ "event" .= ("quit" :: T.Text)
    , "user"  .= user
    ] ++ if isJust msgM
            then ["message" .= fromJust msgM]
            else []

-- }}}

-- {{{ JSON to Events

instance FromJSON BufferEvent where
    parseJSON (Object obj) = do
        evtType <- obj .: "event"
        case evtType :: T.Text of
             "recvmsg" -> ReceivedMessage
                <$> obj .: "sender"
                <*> obj .: "message"
                <*> obj .: "msgtype"
             "join" -> UserJoin <$> obj .: "user"
             "part" -> UserPart <$> obj .: "user" <*> obj .: "messsage"
             "quit" -> UserQuit <$> obj .: "user" <*> obj .: "messsage"
             _ -> empty
    parseJSON _ = empty

-- }}}

